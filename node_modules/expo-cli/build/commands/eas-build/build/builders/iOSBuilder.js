"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _buildTools() {
  const data = require("@expo/build-tools");

  _buildTools = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _once() {
  const data = _interopRequireDefault(require("lodash/once"));

  _once = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _iOSCredentialsProvider() {
  const data = _interopRequireDefault(require("../../../../credentials/provider/iOSCredentialsProvider"));

  _iOSCredentialsProvider = function () {
    return data;
  };

  return data;
}

function ProvisioningProfileUtils() {
  const data = _interopRequireWildcard(require("../../../../credentials/utils/provisioningProfile"));

  ProvisioningProfileUtils = function () {
    return data;
  };

  return data;
}

function _easJson() {
  const data = require("../../../../easJson");

  _easJson = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _prompts() {
  const data = _interopRequireDefault(require("../../../../prompts"));

  _prompts = function () {
    return data;
  };

  return data;
}

function _credentials() {
  const data = require("../credentials");

  _credentials = function () {
    return data;
  };

  return data;
}

function gitUtils() {
  const data = _interopRequireWildcard(require("../utils/git"));

  gitUtils = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class iOSBuilder {
  constructor(ctx) {
    this.ctx = ctx;

    _defineProperty(this, "credentials", void 0);

    _defineProperty(this, "buildProfile", void 0);

    if (!ctx.eas.builds.ios) {
      throw new Error("missing ios configuration, shouldn't happen");
    }

    this.buildProfile = ctx.eas.builds.ios;
  }

  async prepareJobAsync(archiveUrl) {
    if (this.buildProfile.workflow === _easJson().Workflow.Generic) {
      return (0, _buildTools().sanitizeJob)((await this.prepareGenericJobAsync(archiveUrl, this.buildProfile)));
    } else if (this.buildProfile.workflow === _easJson().Workflow.Managed) {
      return (0, _buildTools().sanitizeJob)((await this.prepareManagedJobAsync(archiveUrl, this.buildProfile)));
    } else {
      throw new Error("Unknown workflow. Shouldn't happen");
    }
  }

  async ensureCredentialsAsync() {
    var _this$ctx$exp, _this$ctx$exp$ios;

    if (!this.shouldLoadCredentials()) {
      return;
    }

    const bundleIdentifier = (_this$ctx$exp = this.ctx.exp) === null || _this$ctx$exp === void 0 ? void 0 : (_this$ctx$exp$ios = _this$ctx$exp.ios) === null || _this$ctx$exp$ios === void 0 ? void 0 : _this$ctx$exp$ios.bundleIdentifier;

    if (!bundleIdentifier) {
      throw new Error('"expo.ios.bundleIdentifier" field is required in your app.json');
    }

    const provider = new (_iOSCredentialsProvider().default)(this.ctx.projectDir, {
      projectName: this.ctx.projectName,
      accountName: this.ctx.accountName,
      bundleIdentifier
    });
    await provider.initAsync();
    const credentialsSource = await (0, _credentials().ensureCredentialsAsync)(provider, this.buildProfile.workflow, this.buildProfile.credentialsSource, this.ctx.nonInteractive);
    this.credentials = await provider.getCredentialsAsync(credentialsSource);
  }

  async configureProjectAsync() {
    // TODO: add simulator flow
    // assuming we're building for app store
    if (!this.credentials) {
      throw new Error('Call ensureCredentialsAsync first!');
    }

    const bundleIdentifier = await getBundleIdentifier(this.ctx);
    const spinner = (0, _ora().default)('Making sure your iOS project is set up properly');
    const profileName = ProvisioningProfileUtils().readProfileName(this.credentials.provisioningProfile);
    const appleTeam = ProvisioningProfileUtils().readAppleTeam(this.credentials.provisioningProfile);
    const {
      projectDir
    } = this.ctx;

    _config().IOSConfig.BundleIdenitifer.setBundleIdentifierForPbxproj(projectDir, bundleIdentifier, false);

    _config().IOSConfig.ProvisioningProfile.setProvisioningProfileForPbxproj(projectDir, {
      profileName,
      appleTeamId: appleTeam.teamId
    });

    try {
      await gitUtils().ensureGitStatusIsCleanAsync();
      spinner.succeed();
    } catch (err) {
      if (err instanceof gitUtils().DirtyGitTreeError) {
        spinner.succeed('We configured your iOS project to build it on the Expo servers');

        _log().default.newLine();

        (0, _log().default)('Please review the following changes and pass the message to make the commit.');

        _log().default.newLine();

        await gitUtils().showDiff();

        _log().default.newLine();

        const {
          confirm
        } = await (0, _prompts().default)({
          type: 'confirm',
          name: 'confirm',
          message: 'Can we commit these changes for you?'
        });

        if (confirm) {
          await gitUtils().commitChangesAsync();

          _log().default.newLine();

          (0, _log().default)('âœ… Successfully commited the configuration changes.');
        } else {
          throw new Error("Aborting, run the build command once you're ready. Make sure to commit any changes you've made.");
        }
      } else {
        spinner.fail();
        throw err;
      }
    }
  }

  async prepareJobCommonAsync(archiveUrl) {
    const secrets = this.credentials ? {
      secrets: {
        provisioningProfileBase64: this.credentials.provisioningProfile,
        distributionCertificate: {
          dataBase64: this.credentials.distributionCertificate.certP12,
          password: this.credentials.distributionCertificate.certPassword
        }
      }
    } : {};
    return {
      platform: _buildTools().Platform.iOS,
      projectUrl: archiveUrl,
      ...secrets
    };
  }

  async prepareGenericJobAsync(archiveUrl, buildProfile) {
    return { ...(await this.prepareJobCommonAsync(archiveUrl)),
      type: _buildTools().BuildType.Generic
    };
  }

  async prepareManagedJobAsync(archiveUrl, buildProfile) {
    return { ...(await this.prepareJobCommonAsync(archiveUrl)),
      type: _buildTools().BuildType.Managed,
      packageJson: {
        example: 'packageJson'
      },
      manifest: {
        example: 'manifest'
      }
    };
  }

  shouldLoadCredentials() {
    return this.buildProfile.workflow === _easJson().Workflow.Managed && this.buildProfile.buildType !== 'simulator' || this.buildProfile.workflow === _easJson().Workflow.Generic;
  }

}

const getBundleIdentifier = (0, _once().default)(_getBundleIdentifier);

async function _getBundleIdentifier(ctx) {
  const bundleIdentifierFromPbxproj = _config().IOSConfig.BundleIdenitifer.getBundleIdentifierFromPbxproj(ctx.projectDir);

  const bundleIdentifierFromConfig = _config().IOSConfig.BundleIdenitifer.getBundleIdentifier(ctx.exp);

  if (bundleIdentifierFromPbxproj !== null && bundleIdentifierFromConfig !== null) {
    if (bundleIdentifierFromPbxproj === bundleIdentifierFromConfig) {
      return bundleIdentifierFromPbxproj;
    } else {
      _log().default.newLine();

      (0, _log().default)(_log().default.chalk.yellow(`We detected that your Xcode project is configured with a different bundle identifier than the one defined in app.json/app.config.js.
If you choose the one defined in app.json/app.config.js we'll automatically configure your Xcode project with it.
However, if you choose the one defined in the Xcode project you'll have to update app.json/app.config.js on your own.
Otherwise, you'll see this prompt again in the future.`));

      _log().default.newLine();

      const {
        bundleIdentifier
      } = await (0, _prompts().default)({
        type: 'select',
        name: 'bundleIdentifier',
        message: 'Which bundle identifier should we use?',
        choices: [{
          title: `Defined in the Xcode project: ${_log().default.chalk.bold(bundleIdentifierFromPbxproj)}`,
          value: bundleIdentifierFromPbxproj
        }, {
          title: `Defined in app.json/app.config.js: ${_log().default.chalk.bold(bundleIdentifierFromConfig)}`,
          value: bundleIdentifierFromConfig
        }]
      });
      return bundleIdentifier;
    }
  } else if (bundleIdentifierFromPbxproj === null && bundleIdentifierFromConfig === null) {
    throw new Error('Please define "expo.ios.bundleIdentifier" in app.json/app.config.js');
  } else {
    if (bundleIdentifierFromPbxproj !== null) {
      (0, _log().default)(`Using ${_log().default.chalk.bold(bundleIdentifierFromPbxproj)} as the bundle identifier (read from the Xcode project).`);
      return bundleIdentifierFromPbxproj;
    } else {
      // bundleIdentifierFromConfig is never null in this case
      // the following line is to satisfy TS
      const bundleIdentifier = bundleIdentifierFromConfig !== null && bundleIdentifierFromConfig !== void 0 ? bundleIdentifierFromConfig : '';
      (0, _log().default)(`Using ${_log().default.chalk.bold(bundleIdentifier)} as the bundle identifier (read from app.json/app.config.js).
We'll automatically configure your Xcode project using this value.`);
      return bundleIdentifier;
    }
  }
}

var _default = iOSBuilder;
exports.default = _default;
//# sourceMappingURL=iOSBuilder.js.map