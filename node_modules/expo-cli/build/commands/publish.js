"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.action = action;
exports.default = _default;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _simpleSpinner() {
  const data = _interopRequireDefault(require("@expo/simple-spinner"));

  _simpleSpinner = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _terminalLink() {
  const data = _interopRequireDefault(require("terminal-link"));

  _terminalLink = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _sendTo() {
  const data = _interopRequireDefault(require("../sendTo"));

  _sendTo = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function action(projectDir, options = {}) {
  var _options$target;

  const channelRe = new RegExp(/^[a-z\d][a-z\d._-]*$/);

  if (options.releaseChannel && !channelRe.test(options.releaseChannel)) {
    _log().default.error('Release channel name can only contain lowercase letters, numbers and special characters . _ and -');

    process.exit(1);
  }

  const {
    exp,
    pkg
  } = (0, _config().getConfig)(projectDir, {
    skipSDKVersionRequirement: true
  });

  if (pkg.dependencies['expo-updates'] && pkg.dependencies['expokit']) {
    _log().default.warn(`Warning: You have both the ${_chalk().default.bold('expokit')} and ${_chalk().default.bold('expo-updates')} packages installed in package.json.`);

    _log().default.warn(`These two packages are incompatible and ${_chalk().default.bold('publishing updates with expo-updates will not work if expokit is installed.')}`);

    _log().default.warn(`If you intend to use ${_chalk().default.bold('expo-updates')}, please remove ${_chalk().default.bold('expokit')} from your dependencies.`);
  }

  const hasOptimized = _fs().default.existsSync(_path().default.join(projectDir, '/.expo-shared/assets.json'));

  const nonInteractive = options.parent && options.parent.nonInteractive;

  if (!hasOptimized && !nonInteractive) {
    _log().default.warn('Warning: your project may contain unoptimized image assets. Smaller image sizes can improve app performance.');

    _log().default.warn(`To compress the images in your project, abort publishing and run ${_chalk().default.bold('npx expo-optimize')}.`);

    _log().default.newLine();
  }

  const target = (_options$target = options.target) !== null && _options$target !== void 0 ? _options$target : (0, _config().getDefaultTarget)(projectDir); // Warn users if they attempt to publish in a bare project that may also be
  // using Expo client and does not If the developer does not have the Expo
  // package installed then we do not need to warn them as there is no way that
  // it will run in Expo client in development even. We should revisit this with
  // dev client, and possibly also by excluding SDK version for bare
  // expo-updates usage in the future (and then surfacing this as an error in
  // the Expo client app instead)
  // Related: https://github.com/expo/expo/issues/9517

  if (pkg.dependencies['expo'] && !options.target && target === 'bare') {
    _log().default.warn(`Warning: this is a ${_chalk().default.bold('bare workflow')} project. The resulting publish will only run properly inside of a native build of your project.`);

    _log().default.warn(`If you want to publish a version of your app that will run in Expo client, please use ${_chalk().default.bold('expo publish --target managed')}.`);

    _log().default.warn(`You can skip this warning by explicitly running ${_chalk().default.bold('expo publish --target bare')} in the future.`);

    _log().default.newLine();
  }

  const recipient = await _sendTo().default.getRecipient(options.sendTo);
  (0, _log().default)(`Publishing to channel '${options.releaseChannel}'...`);
  const {
    args: {
      sdkVersion
    }
  } = await _xdl().Exp.getPublishInfoAsync(projectDir);
  const buildStatus = await _xdl().Project.getBuildStatusAsync(projectDir, {
    platform: 'all',
    current: true,
    releaseChannel: options.releaseChannel,
    sdkVersion
  });

  if ('userHasBuiltExperienceBefore' in buildStatus && buildStatus.userHasBuiltExperienceBefore && !buildStatus.userHasBuiltAppBefore && !options.duringBuild && !exp.isDetached) {
    _log().default.warn('We noticed that you have not built a standalone app with this SDK version and release channel before. ' + 'Remember that OTA updates will only work for builds with matching SDK versions and release channels. ' + 'Read more here: https://docs.expo.io/workflow/publishing/#limitations');
  }

  if (options.quiet) {
    _simpleSpinner().default.start();
  }

  const result = await _xdl().Project.publishAsync(projectDir, {
    releaseChannel: options.releaseChannel,
    quiet: options.quiet,
    target
  });
  const url = result.url;

  if (options.quiet) {
    _simpleSpinner().default.stop();
  }

  (0, _log().default)('Publish complete');

  _log().default.newLine();

  const exampleManifestUrl = getExampleManifestUrl(url, exp.sdkVersion);

  if (exampleManifestUrl) {
    (0, _log().default)(`The manifest URL is: ${(0, _terminalLink().default)(url, exampleManifestUrl)}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/manifest-url')}`);
  } else {
    (0, _log().default)(`The manifest URL is: ${(0, _terminalLink().default)(url, url)}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/manifest-url')}`);
  }

  if (target === 'managed') {
    // TODO: replace with websiteUrl from server when it is available, if that makes sense.
    const websiteUrl = url.replace('exp.host', 'expo.io');
    (0, _log().default)(`The project page is: ${(0, _terminalLink().default)(websiteUrl, websiteUrl)}. ${(0, _terminalLink().default)('Learn more.', 'https://expo.fyi/project-page')}`);

    if (recipient) {
      await _sendTo().default.sendUrlAsync(websiteUrl, recipient);
    }
  } else {// This seems pointless in bare?? Leaving it out
    // if (recipient) {
    //   await sendTo.sendUrlAsync(url, recipient);
    // }
  }

  return result;
}

function getExampleManifestUrl(url, sdkVersion) {
  if (!sdkVersion) {
    return null;
  }

  if (url.includes('release-channel') && url.includes('?release-channel')) {
    return url.replace('?release-channel', '/index.exp?release-channel') + `&sdkVersion=${sdkVersion}`;
  } else if (url.includes('?') && !url.includes('release-channel')) {
    // This is the only relevant url query param we are aware of at the time of
    // writing this code, so if there is some other param included we don't know
    // how to deal with it and log nothing.
    return null;
  } else {
    return `${url}/index.exp?sdkVersion=${sdkVersion}`;
  }
}

function _default(program) {
  program.command('publish [project-dir]').alias('p').description('Publishes your project to exp.host').option('-q, --quiet', 'Suppress verbose output from the Metro bundler.').option('-s, --send-to [dest]', 'A phone number or email address to send a link to').option('-c, --clear', 'Clear the Metro bundler cache').option('-t, --target [env]', 'Target environment for which this publish is intended. Options are `managed` or `bare`.') // TODO(anp) set a default for this dynamically based on whether we're inside a container?
  .option('--max-workers [num]', 'Maximum number of tasks to allow Metro to spawn.').option('--release-channel <release channel>', "The release channel to publish to. Default is 'default'.", 'default').asyncActionProjectDir(action);
}
//# sourceMappingURL=publish.js.map