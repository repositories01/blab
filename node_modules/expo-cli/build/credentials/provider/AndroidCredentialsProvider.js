"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _easJson() {
  const data = require("../../easJson");

  _easJson = function () {
    return data;
  };

  return data;
}

function _context() {
  const data = require("../context");

  _context = function () {
    return data;
  };

  return data;
}

function _local() {
  const data = require("../local");

  _local = function () {
    return data;
  };

  return data;
}

function _route() {
  const data = require("../route");

  _route = function () {
    return data;
  };

  return data;
}

function _SetupAndroidKeystore() {
  const data = require("../views/SetupAndroidKeystore");

  _SetupAndroidKeystore = function () {
    return data;
  };

  return data;
}

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AndroidCredentialsProvider {
  constructor(projectDir, options) {
    this.projectDir = projectDir;
    this.options = options;

    _defineProperty(this, "platform", 'android');

    _defineProperty(this, "ctx", new (_context().Context)());
  }

  get projectFullName() {
    const {
      projectName,
      accountName
    } = this.options;
    return `@${accountName}/${projectName}`;
  }

  async initAsync() {
    await this.ctx.init(this.projectDir, {
      nonInteractive: this.ctx.nonInteractive
    });
  }

  async hasRemoteAsync() {
    const keystore = await this.ctx.android.fetchKeystore(this.projectFullName);
    return this.isValidKeystore(keystore);
  }

  async hasLocalAsync() {
    if (!(await _local().credentialsJson.fileExistsAsync(this.projectDir))) {
      return false;
    }

    try {
      const credentials = await _local().credentialsJson.readAndroidAsync(this.projectDir);
      return this.isValidKeystore(credentials.keystore);
    } catch (err) {
      return false;
    }
  }

  async isLocalSyncedAsync() {
    try {
      const [remote, local] = await Promise.all([this.ctx.android.fetchKeystore(this.projectFullName), await _local().credentialsJson.readAndroidAsync(this.projectDir)]);
      const r = remote;
      const l = local === null || local === void 0 ? void 0 : local.keystore;
      return !!(r.keystore === l.keystore && r.keystorePassword === l.keystorePassword && r.keyAlias === l.keyAlias && r.keyPassword === l.keyPassword && this.isValidKeystore(r));
    } catch (_) {
      return false;
    }
  }

  async getCredentialsAsync(src) {
    switch (src) {
      case _easJson().CredentialsSource.LOCAL:
        return await this.getLocalAsync();

      case _easJson().CredentialsSource.REMOTE:
        return await this.getRemoteAsync();
    }
  }

  async getRemoteAsync() {
    await (0, _route().runCredentialsManager)(this.ctx, new (_SetupAndroidKeystore().SetupAndroidKeystore)(this.projectFullName, {
      allowMissingKeystore: false
    }));
    const keystore = await this.ctx.android.fetchKeystore(this.projectFullName);

    if (!keystore || !this.isValidKeystore(keystore)) {
      throw new Error('Unable to set up credentials');
    }

    return {
      keystore
    };
  }

  async getLocalAsync() {
    const credentials = await _local().credentialsJson.readAndroidAsync(this.projectDir);

    if (!this.isValidKeystore(credentials.keystore)) {
      throw new Error('Invalid keystore in credentials.json');
    }

    return credentials;
  }

  isValidKeystore(keystore) {
    return !!(keystore && keystore.keystore && keystore.keystorePassword && keystore.keyPassword && keystore.keyAlias);
  }

}

exports.default = AndroidCredentialsProvider;
//# sourceMappingURL=AndroidCredentialsProvider.js.map